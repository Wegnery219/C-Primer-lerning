# 第四章-表达式
### 一.基础
1. 左值和右值，一个对象被用作右值的时候，用的是对象的值，当对象被用作左值的时候，用的是对象的身份
2. '&&'，'||'，'?:'，','明确规定了求值顺序
3. **如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象**，因为求值规则可能不确定，导致意想不到的效果
`*beg=toupper(*beg++)   //就是个错误的语句`
### 二.算术运算符
1. 布尔值不应该参与运算
2. 参与取余运算的运算对象必须是整数类型
3. C++11标准规定商一律向0取整
### 三.逻辑和关系运算符
1. 与，或有求值顺序，使用的时候可以把危险的条件放在前面，避免对不存在的值进行操作
2. 有一个上一章的点`for(const auto &s:text)`不声明成`for(auto s:text)`的原因是声明成引用可以避免拷贝
3. 进行比较运算时，除非比较的对象是布尔类型，否则不要用true,false作为运算对象
### 四.赋值运算符
1. 满足右结合律，不要与相等运算符'=='混淆
### 五.递增和递减运算符
1. `j=++i;  //先加1，再赋值`</br>`j=i++   //先赋值，再加1`
2. 与解引用混用`*pbeg++`相当于`*(pbeg++)`，先解引用，再向前移动 
### 六.成员访问运算符
1. `ptr->mem`等价于`(*ptr).mem`
### 七.条件运算符
1. 在输出表达式中使用的时候加括号`cout<<((grade<60)?"fail":pass)`
### 八.位运算符
1. 建议只处理无符号运算数
### 九.sizeof
1. 使用sizeof获取数组长度</br>
```
int a[]={45,1,2,3,4,5};
int n=sizeof(a)/sizeof(*a);
```
2. sizeof并不实际计算其运算对象的值
3. 对指针执行sizeof返回指针本身所占空间大小，对解引用指针执行返回指针指向对象大小，指针不需有效。
### 十.逗号运算符
### 十一.类型转换
1. 整形自动转换成浮点型
2. 显示转换：`double slope=static_cast<double>(j)/i;`,不在乎潜在精度损失，可以使用static_cast找回存在于void*指针中的值，（不能直接操纵`void*`所指向的对象），`void *p=&d; double *dp=static_cast<double*> (p);`
3. const_cast,不能用它改变表达式的类型，但是可以改变常量属性，常用于函数重载上下文中，`char *p=const_cast<char*>(p)`
4. 旧式转换和reinterpret_cast类似，如果将int转为char，等一些操作会有危险。
### 小结
本章介绍了表达式中组成元素的使用方法，介绍了很多的运算符，以及它们之间的优先级顺序，同时在编写程序的过程中应当尽量避免类型转换。